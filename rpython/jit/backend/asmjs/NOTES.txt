
there's a lot of mucking about with registers that we don't have to do.
simple set of rules:

  * every box gets a variable
  * load all input args from the frame at function start
  * write result into frame at function end
  * nothing else needs to go in the frame!

"bridge" appears to be a way to extend a failed guard with an additional
trace, turing it into a "trace tree".  need to Verify this, and understand it better.
  - each guard initially jumps to some generic failure-handing code,
    which bails back to the interpreter
  - when we compile a bridge, we are patching that guard to instead jump
    to some newly-compiled assembler that provides a new branch of the
    tree

when you exit from the compiled code, all of the return state goes into the
jitframe:
   - a descr on jf_descr
   - maybe an exception on jf_guard_exc
   - return value somewhere in the frame
   - any args from guards somewhere in the frame


Garbage Collection:
    - how does it even work??
